package ww;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class ww extends JPanel implements ActionListener, KeyListener
{
	 // 游戏参数
	   private final int WIDTH = 600, HEIGHT = 400;
	   private final int BRICK_COLUMNS = 10, BRICK_ROWS = 5;
	   private final int BRICK_WIDTH = WIDTH / BRICK_COLUMNS, BRICK_HEIGHT = 20;
	   private Timer timer;
	   private boolean running = true;
	   
	    private boolean gameWon = false;
	    private boolean gameOver = false;
	    
	   private int ballX = WIDTH / 2, ballY = HEIGHT / 2;
	   private int paddleX = WIDTH / 2;
	   private final int BALL_SIZE = 20, PADDLE_WIDTH = 100, PADDLE_HEIGHT = 10;
	   private int ballDeltaX = -2, ballDeltaY = -2; // 球的移动速度
	   private boolean[][] bricks = new boolean[BRICK_ROWS][BRICK_COLUMNS];
	   private JButton startButton;
	   private boolean ballMoving = false;
	   
	   public ww() {
		   //初始化砖块数组
		   for (int i = 0; i < BRICK_ROWS; i++) {
	           for (int j = 0; j < BRICK_COLUMNS; j++) {
	               bricks[i][j] = true;
	           }
	       }
		   
	       setPreferredSize(new Dimension(WIDTH, HEIGHT));
	       setBackground(Color.BLACK);
	       setFocusable(true);
	       addKeyListener(this);
	 
	       // 设置游戏循环的定时器
	       timer = new Timer(28, this);
	       timer.start();
	       
	       startButton = new JButton("开始游戏");
	       startButton.addActionListener(new ActionListener() {
	           @Override
	           public void actionPerformed(ActionEvent e) {
	               startGame(); // 当按钮被点击时调用 startGame 方法
	           }
	       });
	       add(startButton); // 将按钮添加到面板上
	   }
	 
	   // 游戏主循环
	   public void actionPerformed(ActionEvent e) {
	       if (running && !gameOver && !gameWon) {
	           ballX += ballDeltaX;
	           ballY += ballDeltaY;
	 
	           if (ballMoving) {
	               // 移动小球
	               ballX += ballDeltaX;
	               ballY += ballDeltaY;
	           // 检测墙壁碰撞
	           if (ballX < 0 || ballX > WIDTH - BALL_SIZE) {
	               ballDeltaX *= -1;
	           }
	           if (ballY < 0) {
	               ballDeltaY *= -1;
	           }
	           // 检测挡板碰撞
	           if (ballY > HEIGHT - PADDLE_HEIGHT - BALL_SIZE) {
	               if (ballX > paddleX && ballX < paddleX + PADDLE_WIDTH) {
	                   ballDeltaY *= -1;
	               }
	               
	               else {
	                    gameOver = true;
	               }
	               
	           }
	           
	        // 检测砖块碰撞
	           collisionWithBricks();
	           }
	           repaint();
	       }
	   }
	   
	   // 检测球与砖块的碰撞
	   private void collisionWithBricks() {
	       for (int i = 0; i < BRICK_ROWS; i++) {
	           for (int j = 0; j < BRICK_COLUMNS; j++) {
	               if (bricks[i][j]) {
	                   if (ballX > j * BRICK_WIDTH && ballX < j * BRICK_WIDTH + BRICK_WIDTH &&
	                       ballY > i * BRICK_HEIGHT && ballY < i * BRICK_HEIGHT + BRICK_HEIGHT) {
	                       bricks[i][j] = false; // 移除砖块
	                       ballDeltaY *= -1; // 反转球的方向
	                       break; // 退出内层循环
	                   }
	               }
	           }
	       }
	   }
	   
	   // 检查是否所有砖块都消失
	   private void checkBricks() {
	        boolean allDestroyed = true;
	        for (int i = 0; i < BRICK_ROWS; i++) {
	            for (int j = 0; j < BRICK_COLUMNS; j++) {
	                if (bricks[i][j]) {
	                    allDestroyed = false;
	                    break;
	                }
	            }
	            if (!allDestroyed) {
	                break;
	            }
	        }
	        if (allDestroyed) {
	            gameWon = true;
	            running = false;
	        }
	    }
	   
	   // 绘制游戏元素
	   @Override
	   protected void paintComponent(Graphics g) {
	       super.paintComponent(g);
	       g.setColor(Color.WHITE);
	       g.fillOval(ballX, ballY, BALL_SIZE, BALL_SIZE); // 绘制球
	       g.fillRect(paddleX, HEIGHT - PADDLE_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT); // 绘制挡板
	 
	// 绘制砖块
       for (int i = 0; i < BRICK_ROWS; i++) {
           for (int j = 0; j < BRICK_COLUMNS; j++) {
               if (bricks[i][j]) {
                   g.fillRect(j * BRICK_WIDTH, i * BRICK_HEIGHT, BRICK_WIDTH, BRICK_HEIGHT);
               }
           }
       }
       
       // 绘制游戏结束或胜利信息
       g.setFont(new Font("Arial", Font.BOLD, 30));
       g.setColor(Color.WHITE);
       if (gameOver) {
       	  g.setFont(new Font("Arial", Font.BOLD, 36));
             g.setColor(Color.RED);
             String message = "Game Over";
             g.drawString(message, (WIDTH - g.getFontMetrics().stringWidth(message)) / 2, HEIGHT / 2 - 50);
       } else if (gameWon) {
       	 g.setFont(new Font("Arial", Font.BOLD, 36));
            g.setColor(Color.RED);
       	String successMessage = "Congratulations! You won!";
            g.drawString(successMessage, (WIDTH - g.getFontMetrics().stringWidth(successMessage)) / 2, HEIGHT / 2 - 50);

       }
       
   }

	   // 键盘事件处理
	   @Override
	   public void keyPressed(KeyEvent e) {
	       if (e.getKeyCode() == KeyEvent.VK_LEFT) {
	           paddleX -= 20;
	       }
	       if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
	           paddleX += 20;
	       }
	       // 防止挡板移出边界
	       paddleX = Math.max(paddleX, 0);
	       paddleX = Math.min(paddleX, WIDTH - PADDLE_WIDTH);
	   }
	 
	   @Override
	   public void keyReleased(KeyEvent e) {}
	 
	   @Override
	   public void keyTyped(KeyEvent e) {}
	 
	   public void startGame() {
	       running = true;// 假设有一个变量 running 控制游戏运行
	       startButton.setVisible(false);// 游戏开始后隐藏按钮
	       // 重置小球的位置到挡板处
	       ballX = paddleX + PADDLE_WIDTH / 2 - BALL_SIZE / 2;
	       ballY = HEIGHT - PADDLE_HEIGHT - BALL_SIZE;
	       
	       ballMoving = true; // 设置小球移动的标志为true
	       
	       // 重置小球的移动速度
	       ballDeltaX = -2; // 假设小球初始向左移动
	       ballDeltaY = -2; // 假设小球初始向上移动
	   }
	   
	   public static void main(String[] args) {
	       JFrame frame = new JFrame("打砖块游戏");
	       frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	       ww game = new ww();
           frame.getContentPane().add(game);
	       frame.pack();
	       frame.setLocationRelativeTo(null);
	       frame.setVisible(true);
	    // 启动游戏（如果游戏逻辑中有启动游戏的额外步骤）
	       //game.startGame();
	    }
	     
	    // 在 BreakoutGame 类中，你可以添加一个方法来启动游戏

}
